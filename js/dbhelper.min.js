class DBHelper{static get DATABASE_URL(){const port=1337
    return `http://localhost:${port}/`}
    static fetchTable(tableName,callback,ID){if(navigator.onLine){let xhr=new XMLHttpRequest();xhr.open('GET',DBHelper.DATABASE_URL+tableName);xhr.onload=()=>{if(xhr.status===200){const json=JSON.parse(xhr.responseText);const data=json;DBHelper.dbOpenUpdate(data,tableName,ID);callback(null,data)}else{console.error(`Request ${tableName} failed. Returned status of ${xhr.status}`);DBHelper.dbGet(callback,tableName,ID)}};xhr.send()}else{DBHelper.dbGet(callback,tableName,ID)}}
    static fetchRestaurantById(id,callback){DBHelper.fetchTable('restaurants',(error,restaurants)=>{if(error){callback(error,null)}else{const restaurant=restaurants.find(r=>r.id==id);if(restaurant){callback(null,restaurant)}else{callback('Restaurant does not exist',null)}}},1)}
    static fetchRestaurantByCuisine(cuisine,callback){DBHelper.fetchTable('restaurants',(error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.cuisine_type==cuisine);callback(null,results)}},1)}
    static fetchRestaurantByNeighborhood(neighborhood,callback){DBHelper.fetchTable('restaurants',(error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.neighborhood==neighborhood);callback(null,results)}},1)}
    static fetchRestaurantByCuisineAndNeighborhood(cuisine,neighborhood,callback){DBHelper.fetchTable('restaurants',(error,restaurants)=>{if(error){callback(error,null)}else{let results=restaurants
    if(cuisine!='all'){results=results.filter(r=>r.cuisine_type==cuisine)}
    if(neighborhood!='all'){results=results.filter(r=>r.neighborhood==neighborhood)}
    callback(null,results)}},1)}
    static fetchNeighborhoods(callback){DBHelper.fetchTable('restaurants',(error,restaurants)=>{if(error){callback(error,null)}else{const neighborhoods=restaurants.map((v,i)=>restaurants[i].neighborhood)
    const uniqueNeighborhoods=neighborhoods.filter((v,i)=>neighborhoods.indexOf(v)==i)
    callback(null,uniqueNeighborhoods)}},1)}
    static fetchCuisines(callback){DBHelper.fetchTable('restaurants',(error,restaurants)=>{if(error){callback(error,null)}else{const cuisines=restaurants.map((v,i)=>restaurants[i].cuisine_type)
    const uniqueCuisines=cuisines.filter((v,i)=>cuisines.indexOf(v)==i)
    callback(null,uniqueCuisines)}},1)}
    static urlForRestaurant(restaurant){return(`./restaurant.html?id=${restaurant.id}`)}
    static imageUrlForRestaurant(restaurant){return(`/img/${restaurant.photograph}`)}
    static mapMarkerForRestaurant(restaurant,map){const marker=new google.maps.Marker({position:restaurant.latlng,title:restaurant.name,url:DBHelper.urlForRestaurant(restaurant),map:map,animation:google.maps.Animation.DROP});return marker}
    static dbOpenUpdate(entity,dbName,ID){let objectStore,db;const indexedDB=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;if(!indexedDB){console.error('[ServiceWorker] Your browser doesn`t support indexedDB');return}
    const dbOpenRequest=indexedDB.open(`${dbName}-db`,1);dbOpenRequest.onerror=error=>{console.error('[ServiceWorker] Failed to indexedDB ',error.target)};dbOpenRequest.onsuccess=event=>{db=event.target.result;if(db.transaction){const transaction=db.transaction(dbName,'readwrite');transaction.oncomplete=event=>{console.log('[ServiceWorker] Event on transaction complete ',event)}
    objectStore=transaction.objectStore(dbName);if(dbName=='restaurants')
    objectStore.put({id:ID,restaurants:entity});else if(dbName=='reviews')
    objectStore.put({id:ID,reviews:entity});else if(dbName=='reviews_temp')
    objectStore.put({id:Math.floor((Math.random()*99)),reviews:entity});return}};dbOpenRequest.onupgradeneeded=event=>{db=event.target.result;objectStore=db.createObjectStore(dbName,{keyPath:'id',autoIncrement:!1});objectStore.createIndex(dbName,dbName,{unique:!0});objectStore.transaction.oncomplete=event=>{console.log('[ServiceWorker] Event on transaction complete ',event);objectStore=db.transaction([dbName],'readwrite').objectStore(dbName)}}};static dbGet(callback,dbName,ID){const indexedDB=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;let objectStore,db,data;const request=indexedDB.open(`${dbName}-db`,1);request.onsuccess=event=>{db=request.result;if(db.objectStoreNames.length==0)
    return;if(dbName=='reviews_temp'){const transaction=db.transaction(dbName,'readwrite');transaction.oncomplete=event=>{console.log('[ServiceWorker] Event on transaction complete ',event)}
    objectStore=transaction.objectStore(dbName);objectStore.getAll().onsuccess=event=>{data=event.target.result;if(!data){console.error('[ServiceWorker] Error while fetching data => ',error);callback(error,null);return}
    callback(null,data);data.forEach(review=>{objectStore.delete(review.id).onsuccess=event=>{console.log('[ServiceWorker] Deleted record')}})}}else{const transaction=db.transaction(dbName,'readonly');transaction.oncomplete=event=>{console.log('[ServiceWorker] Event on transaction complete ',event)}
    objectStore=transaction.objectStore(dbName);objectStore.get(ID).onsuccess=event=>{data=event.target.result;if(!data){console.error('[ServiceWorker] Error while fetching data => ',error);callback(error,null);return}
    if(dbName=='restaurants')
    callback(null,data.restaurants);else if(dbName=='reviews')
    callback(null,data.reviews)}}}}}